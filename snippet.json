{
  "Comb": {
    "prefix": "Comb",
    "body": [
      "pub struct Combination {",
      "    fac: Vec<usize>,",
      "    finv: Vec<usize>,",
      "    m: usize,",
      "}",
      "impl Combination {",
      "    pub fn new(n: usize, m: usize) -> Self {",
      "        let mut inv = vec![1; n + 1];",
      "        let mut fac = vec![1; n + 1];",
      "        let mut finv = vec![1; n + 1];",
      "        for i in 2..(n + 1) {",
      "            fac[i] = (fac[i - 1] * i) % m;",
      "            inv[i] = m - (inv[m % i] * (m / i) % m);",
      "            finv[i] = (finv[i - 1] * inv[i]) % m;",
      "        }",
      "        Combination { fac, finv, m }",
      "    }",
      "    pub fn comb(&self, n: usize, k: usize) -> usize {",
      "        if n < k {",
      "            return 0;",
      "        }",
      "        (self.fac[n] * (self.finv[k] * self.finv[n - k] % self.m)) % self.m",
      "    }",
      "}"
    ]
  },
  "Factorize": {
    "prefix": "Factorize",
    "body": [
      "use std::collections::HashMap;",
      "pub struct Factorize {",
      "    fac: Vec<usize>,",
      "}",
      "impl Factorize {",
      "    pub fn new(max_n: usize) -> Self {",
      "        let mut fac: Vec<usize> = (0..=max_n).collect();",
      "        let mut i = 2;",
      "        while i * i <= max_n {",
      "            if fac[i] == i {",
      "                for j in (i * i..=max_n).step_by(i) {",
      "                    if fac[j] == j {",
      "                        fac[j] = i;",
      "                    }",
      "                }",
      "            }",
      "            i += 1;",
      "        }",
      "        Factorize { fac }",
      "    }",
      "    pub fn factorize(&self, n: usize) -> HashMap<usize, usize> {",
      "        let mut hm = HashMap::new();",
      "        let mut tmp = n;",
      "        while tmp != 1 {",
      "            let cnt = hm.entry(self.fac[tmp]).or_insert(0);",
      "            *cnt += 1;",
      "            tmp /= self.fac[tmp];",
      "        }",
      "        hm",
      "    }",
      "}"
    ]
  },
  "Graph": {
    "prefix": "Graph",
    "body": [
      "type Graph = Vec<Vec<Edge>>;",
      "#[derive(Debug, Copy, Clone)]",
      "pub struct Edge {",
      "    pub to: usize,",
      "    pub cost: usize,",
      "}",
      "impl Edge {",
      "    pub fn new(to: usize, cost: usize) -> Self {",
      "        Self { to, cost }",
      "    }",
      "}"
    ]
  },
  "Modint": {
    "prefix": "Modint",
    "body": [
      "use std::mem::swap;",
      "#[derive(Copy, Clone, Debug)]",
      "pub struct Modint<const MOD: usize> {",
      "    val: usize,",
      "}",
      "impl<const MOD: usize> Modint<MOD> {",
      "    pub fn new(val: usize) -> Self {",
      "        Modint { val: val % MOD }",
      "    }",
      "    pub fn inv(&self) -> Self {",
      "        let mut x: i32 = 1;",
      "        let mut u: i32 = 0;",
      "        let mut s: i32 = self.val as i32;",
      "        let mut t: i32 = MOD as i32;",
      "        while t != 0 {",
      "            let k = s / t;",
      "            s -= k * t;",
      "            swap(&mut s, &mut t);",
      "            x -= k * t;",
      "            swap(&mut x, &mut u);",
      "        }",
      "        x %= MOD as i32;",
      "        if x < 0 {",
      "            x += MOD as i32;",
      "        }",
      "        let x = x as usize;",
      "        Modint { val: x }",
      "    }",
      "}",
      "impl<const MOD: usize> Add for Modint<MOD> {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        Self {",
      "            val: (self.val + rhs.val) % MOD,",
      "        }",
      "    }",
      "}",
      "impl<const MOD: usize> AddAssign for Modint<MOD> {",
      "    fn add_assign(&mut self, rhs: Modint<MOD>) {",
      "        *self = *self + rhs;",
      "    }",
      "}",
      "impl<const MOD: usize> Sub for Modint<MOD> {",
      "    type Output = Self;",
      "    fn sub(self, other: Self) -> Self {",
      "        Self {",
      "            val: (MOD + self.val - other.val) % MOD,",
      "        }",
      "    }",
      "}",
      "impl<const MOD: usize> SubAssign for Modint<MOD> {",
      "    fn sub_assign(&mut self, rhs: Modint<MOD>) {",
      "        *self = *self - rhs;",
      "    }",
      "}",
      "impl<const MOD: usize> Mul for Modint<MOD> {",
      "    type Output = Modint<MOD>;",
      "    fn mul(self, rhs: Modint<MOD>) -> Self {",
      "        Modint {",
      "            val: (self.val * rhs.val) % MOD,",
      "        }",
      "    }",
      "}",
      "impl<const MOD: usize> MulAssign for Modint<MOD> {",
      "    fn mul_assign(&mut self, rhs: Modint<MOD>) {",
      "        *self = *self * rhs;",
      "    }",
      "}",
      "impl<const MOD: usize> Div for Modint<MOD> {",
      "    type Output = Modint<MOD>;",
      "    fn div(self, rhs: Modint<MOD>) -> Self {",
      "        Modint {",
      "            val: (self.val * rhs.inv().val) % MOD,",
      "        }",
      "    }",
      "}",
      "impl<const MOD: usize> DivAssign for Modint<MOD> {",
      "    fn div_assign(&mut self, rhs: Modint<MOD>) {",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "impl<const MOD: usize> From<i32> for Modint<MOD> {",
      "    fn from(x: i32) -> Self {",
      "        let mut tmp = x;",
      "        while tmp < 0 {",
      "            tmp += MOD as i32;",
      "        }",
      "        let res = Modint::new(tmp as usize);",
      "        res",
      "    }",
      "}",
      "impl<const MOD: usize> From<usize> for Modint<MOD> {",
      "    fn from(x: usize) -> Self {",
      "        let res = Modint::new(x);",
      "        res",
      "    }",
      "}",
      "impl<const MOD: usize> std::fmt::Display for Modint<MOD> {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.val)",
      "    }",
      "}",
      "impl<const MOD: usize> PartialEq for Modint<MOD> {",
      "    fn eq(&self, other: &Self) -> bool {",
      "        self.val == other.val",
      "    }",
      "}"
    ]
  },
  "SPT": {
    "prefix": "SPT",
    "body": [
      "pub struct SparseTable<T: Ord + Copy + Default> {",
      "    table: Vec<Vec<T>>,",
      "    log_table: Vec<usize>,",
      "}",
      "impl<T: Ord + Copy + Default> SparseTable<T> {",
      "    pub fn new(arr: &[T]) -> Self {",
      "        let mut b = 0;",
      "        let n = arr.len();",
      "        while (1 << b) <= n {",
      "            b += 1;",
      "        }",
      "        let mut table: Vec<Vec<T>> = vec![vec![T::default(); n]; b];",
      "        for i in 0..n {",
      "            table[0][i] = arr[i];",
      "        }",
      "        for i in 1..b {",
      "            for j in 0..=(n - (1 << i)) {",
      "                table[i][j] = std::cmp::min(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);",
      "            }",
      "        }",
      "        let mut log_table = vec![0; n + 1];",
      "        for i in 2..(n + 1) {",
      "            log_table[i] = log_table[i >> 1] + 1;",
      "        }",
      "        Self { table, log_table }",
      "    }",
      "    #[inline]",
      "    pub fn query(&self, l: usize, r: usize) -> T {",
      "        let k = self.log_table[r - l];",
      "        std::cmp::min(self.table[k][l], self.table[k][r - (1 << k)])",
      "    }",
      "}"
    ]
  },
  "Segtree": {
    "prefix": "Segtree",
    "body": [
      "pub struct Segtree<T: Copy> {",
      "    n: usize,",
      "    data: Vec<T>,",
      "    identity: T,",
      "    op: fn(T, T) -> T,",
      "}",
      "impl<T: Copy> Segtree<T> {",
      "    pub fn new(arr: &Vec<T>, identity: T, op: fn(T, T) -> T) -> Self {",
      "        let n = arr.len();",
      "        let mut b = 1;",
      "        while b < n {",
      "            b <<= 1;",
      "        }",
      "        let mut data = vec![identity; 2 * b];",
      "        for i in 0..n {",
      "            data[i + b] = arr[i];",
      "        }",
      "        for i in (0..b).rev() {",
      "            data[i] = op(data[(i << 1)], data[(i << 1) + 1]);",
      "        }",
      "        Self {",
      "            n: b,",
      "            data,",
      "            identity,",
      "            op,",
      "        }",
      "    }",
      "    pub fn set(&mut self, mut id: usize, val: T) {",
      "        id += self.n;",
      "        self.data[id] = val;",
      "        id >>= 1;",
      "        while id > 0 {",
      "            self.data[id] = (self.op)(self.data[(id << 1)], self.data[(id << 1) + 1]);",
      "            id >>= 1;",
      "        }",
      "    }",
      "    pub fn get(&self, i: usize) -> T {",
      "        self.data[i + self.n]",
      "    }",
      "    pub fn prod(&self, mut l: usize, mut r: usize) -> T {",
      "        let mut vl = self.identity;",
      "        let mut vr = self.identity;",
      "        l += self.n;",
      "        r += self.n;",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                vl = (self.op)(vl, self.data[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                vr = (self.op)(self.data[r], vr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        (self.op)(vl, vr)",
      "    }",
      "    pub fn all_prod(&self) -> T {",
      "        self.data[1]",
      "    }",
      "}"
    ]
  },
  "UFT": {
    "prefix": "UFT",
    "body": [
      "pub struct UnionFind {",
      "    par: Vec<usize>,",
      "    siz: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            par: (0..n).into_iter().collect(),",
      "            siz: vec![1; n],",
      "        }",
      "    }",
      "    pub fn root(&mut self, x: usize) -> usize {",
      "        if self.par[x] != x {",
      "            self.par[x] = self.root(self.par[x]);",
      "        }",
      "        self.par[x]",
      "    }",
      "    pub fn unite(&mut self, a: usize, b: usize) {",
      "        let (mut ra, mut rb) = (self.root(a), self.root(b));",
      "        if ra == rb {",
      "            return;",
      "        }",
      "        if self.siz[ra] < self.siz[rb] {",
      "            std::mem::swap(&mut ra, &mut rb);",
      "        }",
      "        self.siz[ra] += self.siz[rb];",
      "        self.par[rb] = ra;",
      "    }",
      "    pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "        self.root(a) == self.root(b)",
      "    }",
      "    /// This function is cited from ac-library-rs.",
      "    pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "        let size = self.par.len();",
      "        let mut root_vec = vec![0; size];",
      "        let mut group_size = vec![0; size];",
      "        for i in 0..size {",
      "            root_vec[i] = self.root(i);",
      "            group_size[root_vec[i]] += 1;",
      "        }",
      "        let mut result = vec![Vec::new(); size];",
      "        for i in 0..size {",
      "            result[i].reserve(group_size[i]);",
      "        }",
      "        for i in 0..size {",
      "            result[root_vec[i]].push(i);",
      "        }",
      "        result",
      "            .into_iter()",
      "            .filter(|x| !x.is_empty())",
      "            .collect::<Vec<Vec<usize>>>()",
      "    }",
      "}"
    ]
  },
  "ext_gcd": {
    "prefix": "ext_gcd",
    "body": [
      "pub fn ext_gcd(mut a: i64, mut b: i64) -> (i64, i64) {",
      "    let mut x = 1;",
      "    let mut y = 0;",
      "    let mut u = 0;",
      "    let mut v = 1;",
      "    while b > 0 {",
      "        let k = a / b;",
      "        x -= k * u;",
      "        y -= k * v;",
      "        std::mem::swap(&mut x, &mut u);",
      "        std::mem::swap(&mut y, &mut v);",
      "        let r = a % b;",
      "        a = b;",
      "        b = r;",
      "    }",
      "    (x, y)",
      "}"
    ]
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "pub fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "lcm": {
    "prefix": "lcm",
    "body": [
      "pub fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "pub fn lcm(a: usize, b: usize) -> usize {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "mod_inv": {
    "prefix": "mod_inv",
    "body": [
      "pub fn ext_gcd(mut a: i64, mut b: i64) -> (i64, i64) {",
      "    let mut x = 1;",
      "    let mut y = 0;",
      "    let mut u = 0;",
      "    let mut v = 1;",
      "    while b > 0 {",
      "        let k = a / b;",
      "        x -= k * u;",
      "        y -= k * v;",
      "        std::mem::swap(&mut x, &mut u);",
      "        std::mem::swap(&mut y, &mut v);",
      "        let r = a % b;",
      "        a = b;",
      "        b = r;",
      "    }",
      "    (x, y)",
      "}",
      "pub fn mod_inv(a: usize, m: i64) -> usize {",
      "    let (mut x, _) = ext_gcd(a as i64, m as i64);",
      "    x %= m;",
      "    if x < 0 {",
      "        x += m",
      "    }",
      "    x as usize",
      "}"
    ]
  },
  "prime_factorize": {
    "prefix": "prime_factorize",
    "body": [
      "fn prime_factorize(mut n: usize) -> Vec<(usize, usize)> {",
      "    let mut res = vec![];",
      "    let mut i = 2;",
      "    while i * i <= n {",
      "        if n % i != 0 {",
      "            i += 1;",
      "            continue;",
      "        }",
      "        let mut ex = 0;",
      "        while n % i == 0 {",
      "            ex += 1;",
      "            n /= i;",
      "        }",
      "        res.push((i, ex));",
      "        i += 1;",
      "    }",
      "    if n != 1 {",
      "        res.push((n, 1));",
      "    }",
      "    res",
      "}"
    ]
  },
  "prime_list": {
    "prefix": "prime_list",
    "body": [
      "pub fn prime_list(n: usize) -> Vec<usize> {",
      "    let mut list = vec![];",
      "    let mut is_prime = vec![true; n + 1];",
      "    for i in 2..n {",
      "        if !is_prime[i] {",
      "            continue;",
      "        }",
      "        list.push(i);",
      "        for j in (i * 2..=n).into_iter().step_by(i) {",
      "            is_prime[j] = false;",
      "        }",
      "    }",
      "    list",
      "}"
    ]
  },
  "shortest_path": {
    "prefix": "shortest_path",
    "body": [
      "type Graph = Vec<Vec<Edge>>;",
      "#[derive(Debug, Copy, Clone)]",
      "pub struct Edge {",
      "    pub to: usize,",
      "    pub cost: usize,",
      "}",
      "impl Edge {",
      "    pub fn new(to: usize, cost: usize) -> Self {",
      "        Self { to, cost }",
      "    }",
      "}",
      "pub fn shortest_path(graph: &Graph, start: usize, goal: usize) -> (usize, Vec<usize>) {",
      "    use std::cmp::Reverse;",
      "    let mut dist = vec![usize::MAX / 2; graph.len()];",
      "    let mut prev = vec![None; graph.len()];",
      "    dist[start] = 0;",
      "    let mut pq = std::collections::BinaryHeap::new();",
      "    pq.push(Reverse((0, start)));",
      "    while let Some(Reverse((cost, pos))) = pq.pop() {",
      "        if dist[pos] < cost {",
      "            continue;",
      "        }",
      "        for edge in &graph[pos] {",
      "            if dist[edge.to] > dist[pos] + edge.cost {",
      "                dist[edge.to] = dist[pos] + edge.cost;",
      "                pq.push(Reverse((dist[edge.to], edge.to)));",
      "                prev[edge.to] = Some(pos);",
      "            }",
      "        }",
      "    }",
      "    let mut id = goal;",
      "    let mut path = vec![goal];",
      "    while let Some(v) = prev[id] {",
      "        path.push(v);",
      "        id = v;",
      "    }",
      "    path.reverse();",
      "    (dist[goal], path)",
      "}"
    ]
  }
}
