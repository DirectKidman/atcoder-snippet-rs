{
  "CRT": {
    "prefix": "CRT",
    "body": [
      "pub fn ext_gcd(a: i64, b: i64) -> (i64, i64, i64) {",
      "    if b == 0 {",
      "        (a, 1, 0)",
      "    } else {",
      "        let (d, q, p) = ext_gcd(b, a % b);",
      "        (d, p, q - a / b * p)",
      "    }",
      "}",
      "pub fn chinese_remainder_theorem(b: &[i64], modulo: &[i64]) -> Option<(i64, i64)> {",
      "    let (mut result, mut m) = (0, 1);",
      "    for i in 0..b.len() {",
      "        let (d, p, _) = ext_gcd(m, modulo[i]);",
      "        if (b[i] - result) % d != 0 {",
      "            return None;",
      "        }",
      "        let tmp = ((b[i] - result) / d * p) % (modulo[i] / d);",
      "        result += m * tmp;",
      "        m *= modulo[i] / d;",
      "    }",
      "    Some(((result % m + m) % m, m))",
      "}"
    ]
  },
  "Comb": {
    "prefix": "Comb",
    "body": [
      "pub struct Combination {",
      "    fac: Vec<usize>,",
      "    finv: Vec<usize>,",
      "    m: usize,",
      "}",
      "impl Combination {",
      "    pub fn new(n: usize, m: usize) -> Self {",
      "        let mut inv = vec![1; n + 1];",
      "        let mut fac = vec![1; n + 1];",
      "        let mut finv = vec![1; n + 1];",
      "        for i in 2..(n + 1) {",
      "            fac[i] = (fac[i - 1] * i) % m;",
      "            inv[i] = m - (inv[m % i] * (m / i) % m);",
      "            finv[i] = (finv[i - 1] * inv[i]) % m;",
      "        }",
      "        Combination { fac, finv, m }",
      "    }",
      "    pub fn comb(&self, n: usize, k: usize) -> usize {",
      "        if n < k {",
      "            return 0;",
      "        }",
      "        (self.fac[n] * (self.finv[k] * self.finv[n - k] % self.m)) % self.m",
      "    }",
      "}"
    ]
  },
  "Factorize": {
    "prefix": "Factorize",
    "body": [
      "use std::collections::BTreeMap;",
      "pub struct Factorize {",
      "    fac: Vec<usize>,",
      "}",
      "impl Factorize {",
      "    pub fn new(max_n: usize) -> Self {",
      "        let mut fac: Vec<usize> = (0..=max_n).collect();",
      "        let mut i = 2;",
      "        while i * i <= max_n {",
      "            if fac[i] == i {",
      "                for j in (i * i..=max_n).step_by(i) {",
      "                    if fac[j] == j {",
      "                        fac[j] = i;",
      "                    }",
      "                }",
      "            }",
      "            i += 1;",
      "        }",
      "        Factorize { fac }",
      "    }",
      "    pub fn factorize(&self, n: usize) -> BTreeMap<usize, usize> {",
      "        let mut hm = BTreeMap::new();",
      "        let mut tmp = n;",
      "        while tmp != 1 {",
      "            let cnt = hm.entry(self.fac[tmp]).or_insert(0);",
      "            *cnt += 1;",
      "            tmp /= self.fac[tmp];",
      "        }",
      "        hm",
      "    }",
      "}"
    ]
  },
  "Graph": {
    "prefix": "Graph",
    "body": [
      "type Graph = Vec<Vec<Edge>>;",
      "#[derive(Debug, Copy, Clone)]",
      "pub struct Edge {",
      "    pub to: usize,",
      "    pub cost: usize,",
      "}",
      "impl Edge {",
      "    pub fn new(to: usize, cost: usize) -> Self {",
      "        Self { to, cost }",
      "    }",
      "}"
    ]
  },
  "Modint": {
    "prefix": "Modint",
    "body": [
      "use std::mem::swap;",
      "#[derive(Copy, Clone, Debug)]",
      "pub struct Modint<const MOD: usize> {",
      "    val: usize,",
      "}",
      "impl<const MOD: usize> Modint<MOD> {",
      "    pub fn new(val: usize) -> Self {",
      "        Modint { val: val % MOD }",
      "    }",
      "    pub fn inv(&self) -> Self {",
      "        let mut x: i32 = 1;",
      "        let mut u: i32 = 0;",
      "        let mut s: i32 = self.val as i32;",
      "        let mut t: i32 = MOD as i32;",
      "        while t != 0 {",
      "            let k = s / t;",
      "            s -= k * t;",
      "            swap(&mut s, &mut t);",
      "            x -= k * t;",
      "            swap(&mut x, &mut u);",
      "        }",
      "        x %= MOD as i32;",
      "        if x < 0 {",
      "            x += MOD as i32;",
      "        }",
      "        let x = x as usize;",
      "        Modint { val: x }",
      "    }",
      "}",
      "impl<const MOD: usize> Add for Modint<MOD> {",
      "    type Output = Self;",
      "    fn add(self, rhs: Self) -> Self {",
      "        Self {",
      "            val: (self.val + rhs.val) % MOD,",
      "        }",
      "    }",
      "}",
      "impl<const MOD: usize> AddAssign for Modint<MOD> {",
      "    fn add_assign(&mut self, rhs: Modint<MOD>) {",
      "        *self = *self + rhs;",
      "    }",
      "}",
      "impl<const MOD: usize> Sub for Modint<MOD> {",
      "    type Output = Self;",
      "    fn sub(self, other: Self) -> Self {",
      "        Self {",
      "            val: (MOD + self.val - other.val) % MOD,",
      "        }",
      "    }",
      "}",
      "impl<const MOD: usize> SubAssign for Modint<MOD> {",
      "    fn sub_assign(&mut self, rhs: Modint<MOD>) {",
      "        *self = *self - rhs;",
      "    }",
      "}",
      "impl<const MOD: usize> Mul for Modint<MOD> {",
      "    type Output = Modint<MOD>;",
      "    fn mul(self, rhs: Modint<MOD>) -> Self {",
      "        Modint {",
      "            val: (self.val * rhs.val) % MOD,",
      "        }",
      "    }",
      "}",
      "impl<const MOD: usize> MulAssign for Modint<MOD> {",
      "    fn mul_assign(&mut self, rhs: Modint<MOD>) {",
      "        *self = *self * rhs;",
      "    }",
      "}",
      "impl<const MOD: usize> Div for Modint<MOD> {",
      "    type Output = Modint<MOD>;",
      "    fn div(self, rhs: Modint<MOD>) -> Self {",
      "        Modint {",
      "            val: (self.val * rhs.inv().val) % MOD,",
      "        }",
      "    }",
      "}",
      "impl<const MOD: usize> DivAssign for Modint<MOD> {",
      "    fn div_assign(&mut self, rhs: Modint<MOD>) {",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "impl<const MOD: usize> From<i32> for Modint<MOD> {",
      "    fn from(x: i32) -> Self {",
      "        let mut tmp = x;",
      "        while tmp < 0 {",
      "            tmp += MOD as i32;",
      "        }",
      "        let res = Modint::new(tmp as usize);",
      "        res",
      "    }",
      "}",
      "impl<const MOD: usize> From<usize> for Modint<MOD> {",
      "    fn from(x: usize) -> Self {",
      "        let res = Modint::new(x);",
      "        res",
      "    }",
      "}",
      "impl<const MOD: usize> std::fmt::Display for Modint<MOD> {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.val)",
      "    }",
      "}",
      "impl<const MOD: usize> PartialEq for Modint<MOD> {",
      "    fn eq(&self, other: &Self) -> bool {",
      "        self.val == other.val",
      "    }",
      "}"
    ]
  },
  "NTT": {
    "prefix": "NTT",
    "body": [
      "pub struct FastFourierTransform {",
      "    modulo: i64,",
      "    sum_e: [i64; 30],",
      "    sum_ie: [i64; 30],",
      "}",
      "impl FastFourierTransform {",
      "    pub fn new(modulo: i64) -> Self {",
      "        let primitive_root = primitive_root(modulo);",
      "        let mut es = [0; 30];",
      "        let mut ies = [0; 30];",
      "        let count2 = (modulo - 1).trailing_zeros();",
      "        let mut e = mod_pow(primitive_root, (modulo - 1) >> count2, modulo);",
      "        let mut ie = mod_inv(e, modulo);",
      "        let count2 = count2 as usize;",
      "        for i in (2..=count2).rev() {",
      "            es[i - 2] = e;",
      "            ies[i - 2] = ie;",
      "            e = (e * e) % modulo;",
      "            ie = (ie * ie) % modulo;",
      "        }",
      "        let mut sum_e = [0; 30];",
      "        let mut now = 1;",
      "        for i in 0..=(count2 - 2) {",
      "            sum_e[i] = (es[i] * now) % modulo;",
      "            now = (now * ies[i]) % modulo;",
      "        }",
      "        let mut sum_ie = [0; 30];",
      "        let mut now = 1;",
      "        for i in 0..=(count2 - 2) {",
      "            sum_ie[i] = (ies[i] * now) % modulo;",
      "            now = (now * es[i]) % modulo;",
      "        }",
      "        Self {",
      "            sum_e,",
      "            modulo,",
      "            sum_ie,",
      "        }",
      "    }",
      "    fn butterfly(&self, a: &mut [i64]) {",
      "        let h = a.len().next_power_of_two().trailing_zeros();",
      "        for ph in 1..=h {",
      "            let w = 1 << (ph - 1);",
      "            let p = 1 << (h - ph);",
      "            let mut now = 1;",
      "            for s in 0..w {",
      "                let offset = s << (h - ph + 1);",
      "                for i in 0..p {",
      "                    let l = a[i + offset];",
      "                    let r = (a[i + offset + p] * now) % self.modulo;",
      "                    a[i + offset] = l + r;",
      "                    if a[i + offset] >= self.modulo {",
      "                        a[i + offset] -= self.modulo;",
      "                    }",
      "                    a[i + offset + p] = l + self.modulo - r;",
      "                    if a[i + offset + p] >= self.modulo {",
      "                        a[i + offset + p] -= self.modulo;",
      "                    }",
      "                }",
      "                now = (self.sum_e[(!s).trailing_zeros() as usize] * now) % self.modulo;",
      "            }",
      "        }",
      "    }",
      "    fn butterfly_inv(&self, a: &mut [i64]) {",
      "        let h = a.len().next_power_of_two().trailing_zeros();",
      "        for ph in (1..=h).rev() {",
      "            let w = 1 << (ph - 1);",
      "            let p = 1 << (h - ph);",
      "            let mut inv_now = 1;",
      "            for s in 0..w {",
      "                let offset = s << (h - ph + 1);",
      "                for i in 0..p {",
      "                    let l = a[i + offset];",
      "                    let r = a[i + offset + p];",
      "                    a[i + offset] = l + r;",
      "                    if a[i + offset] >= self.modulo {",
      "                        a[i + offset] -= self.modulo;",
      "                    }",
      "                    a[i + offset + p] = ((l + self.modulo - r) * inv_now) % self.modulo;",
      "                }",
      "                inv_now = (self.sum_ie[(!s).trailing_zeros() as usize] * inv_now) % self.modulo;",
      "            }",
      "        }",
      "    }",
      "    pub fn convolution(&self, a: &[i64], b: &[i64]) -> Vec<i64> {",
      "        if a.is_empty() || b.is_empty() {",
      "            return Vec::new();",
      "        }",
      "        let n = a.len();",
      "        let m = b.len();",
      "        let z = (n + m - 1).next_power_of_two();",
      "        let mut a = a.iter().map(|&v| v % self.modulo).collect::<Vec<_>>();",
      "        a.resize(z, 0);",
      "        self.butterfly(&mut a);",
      "        let mut b = b.iter().map(|&v| v % self.modulo).collect::<Vec<_>>();",
      "        b.resize(z, 0);",
      "        self.butterfly(&mut b);",
      "        for i in 0..z {",
      "            a[i] = (a[i] * b[i]) % self.modulo;",
      "        }",
      "        self.butterfly_inv(&mut a);",
      "        a.resize(n + m - 1, 0);",
      "        let iz = mod_inv(z as i64, self.modulo);",
      "        for i in 0..a.len() {",
      "            a[i] = (a[i] * iz) % self.modulo;",
      "        }",
      "        a",
      "    }",
      "}",
      "fn mod_inv(x: i64, m: i64) -> i64 {",
      "    mod_pow(x, m - 2, m)",
      "}",
      "fn mod_pow(x: i64, mut e: i64, m: i64) -> i64 {",
      "    let mut cur = x;",
      "    let mut result = 1;",
      "    while e > 0 {",
      "        if e & 1 == 1 {",
      "            result = (result * cur) % m;",
      "        }",
      "        e >>= 1;",
      "        cur = (cur * cur) % m;",
      "    }",
      "    result",
      "}",
      "fn primitive_root(m: i64) -> i64 {",
      "    if m == 2 {",
      "        return 1;",
      "    };",
      "    if m == 167772161 {",
      "        return 3;",
      "    };",
      "    if m == 469762049 {",
      "        return 3;",
      "    };",
      "    if m == 754974721 {",
      "        return 11;",
      "    };",
      "    if m == 998244353 {",
      "        return 3;",
      "    };",
      "    let mut divs = [0; 20];",
      "    divs[0] = 2;",
      "    let mut cnt = 1;",
      "    let mut x = (m - 1) / 2;",
      "    while x % 2 == 0 {",
      "        x /= 2",
      "    }",
      "    let mut i = 3;",
      "    while i * i <= x {",
      "        if x % i == 0 {",
      "            divs[cnt] = i;",
      "            cnt += 1;",
      "            while x % i == 0 {",
      "                x /= i;",
      "            }",
      "        }",
      "        i += 2;",
      "    }",
      "    if x > 1 {",
      "        divs[cnt] = x;",
      "        cnt += 1;",
      "    }",
      "    for g in 2.. {",
      "        let mut ok = true;",
      "        for i in 0..cnt {",
      "            if mod_pow(g, (m - 1) / divs[i], m) == 1 {",
      "                ok = false;",
      "                break;",
      "            }",
      "        }",
      "        if ok {",
      "            return g;",
      "        }",
      "    }",
      "    unreachable!()",
      "}"
    ]
  },
  "SPT": {
    "prefix": "SPT",
    "body": [
      "pub struct SparseTable<T: Ord + Copy + Default> {",
      "    table: Vec<Vec<T>>,",
      "    log_table: Vec<usize>,",
      "}",
      "impl<T: Ord + Copy + Default> SparseTable<T> {",
      "    pub fn new(arr: &[T]) -> Self {",
      "        let mut b = 0;",
      "        let n = arr.len();",
      "        while (1 << b) <= n {",
      "            b += 1;",
      "        }",
      "        let mut table: Vec<Vec<T>> = vec![vec![T::default(); n]; b];",
      "        for i in 0..n {",
      "            table[0][i] = arr[i];",
      "        }",
      "        for i in 1..b {",
      "            for j in 0..=(n - (1 << i)) {",
      "                table[i][j] = std::cmp::min(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);",
      "            }",
      "        }",
      "        let mut log_table = vec![0; n + 1];",
      "        for i in 2..(n + 1) {",
      "            log_table[i] = log_table[i >> 1] + 1;",
      "        }",
      "        Self { table, log_table }",
      "    }",
      "    #[inline]",
      "    pub fn query(&self, l: usize, r: usize) -> T {",
      "        let k = self.log_table[r - l];",
      "        std::cmp::min(self.table[k][l], self.table[k][r - (1 << k)])",
      "    }",
      "}"
    ]
  },
  "Segtree": {
    "prefix": "Segtree",
    "body": [
      "pub struct Segtree<T: Copy, Op> {",
      "    n: usize,",
      "    data: Vec<T>,",
      "    identity: T,",
      "    op: Op,",
      "}",
      "impl<T, Op> Segtree<T, Op>",
      "where",
      "    T: Copy,",
      "    Op: Fn(T, T) -> T + Copy,",
      "{",
      "    pub fn new(arr: &Vec<T>, identity: T, op: Op) -> Self {",
      "        let n = arr.len();",
      "        let mut b = 1;",
      "        while b < n {",
      "            b <<= 1;",
      "        }",
      "        let mut data = vec![identity; 2 * b];",
      "        for i in 0..n {",
      "            data[i + b] = arr[i];",
      "        }",
      "        for i in (0..b).rev() {",
      "            data[i] = op(data[(i << 1)], data[(i << 1) + 1]);",
      "        }",
      "        Self {",
      "            n: b,",
      "            data,",
      "            identity,",
      "            op,",
      "        }",
      "    }",
      "    pub fn set(&mut self, mut id: usize, val: T) {",
      "        id += self.n;",
      "        self.data[id] = val;",
      "        id >>= 1;",
      "        while id > 0 {",
      "            self.data[id] = (self.op)(self.data[(id << 1)], self.data[(id << 1) + 1]);",
      "            id >>= 1;",
      "        }",
      "    }",
      "    pub fn get(&self, i: usize) -> T {",
      "        self.data[i + self.n]",
      "    }",
      "    pub fn prod(&self, mut l: usize, mut r: usize) -> T {",
      "        let mut vl = self.identity;",
      "        let mut vr = self.identity;",
      "        l += self.n;",
      "        r += self.n;",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                vl = (self.op)(vl, self.data[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                vr = (self.op)(self.data[r], vr);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        (self.op)(vl, vr)",
      "    }",
      "    pub fn all_prod(&self) -> T {",
      "        self.data[1]",
      "    }",
      "}"
    ]
  },
  "UFT": {
    "prefix": "UFT",
    "body": [
      "pub struct UnionFind {",
      "    par: Vec<usize>,",
      "    siz: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            par: (0..n).collect(),",
      "            siz: vec![1; n],",
      "        }",
      "    }",
      "    pub fn root(&mut self, x: usize) -> usize {",
      "        if self.par[x] != x {",
      "            self.par[x] = self.root(self.par[x]);",
      "        }",
      "        self.par[x]",
      "    }",
      "    pub fn unite(&mut self, a: usize, b: usize) {",
      "        let (mut ra, mut rb) = (self.root(a), self.root(b));",
      "        if ra == rb {",
      "            return;",
      "        }",
      "        if self.siz[ra] < self.siz[rb] {",
      "            std::mem::swap(&mut ra, &mut rb);",
      "        }",
      "        self.siz[ra] += self.siz[rb];",
      "        self.par[rb] = ra;",
      "    }",
      "    pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "        self.root(a) == self.root(b)",
      "    }",
      "    /// This function is cited from ac-library-rs.",
      "    pub fn groups(&mut self) -> Vec<Vec<usize>> {",
      "        let size = self.par.len();",
      "        let mut root_vec = vec![0; size];",
      "        let mut group_size = vec![0; size];",
      "        for i in 0..size {",
      "            root_vec[i] = self.root(i);",
      "            group_size[root_vec[i]] += 1;",
      "        }",
      "        let mut result = vec![Vec::new(); size];",
      "        for i in 0..size {",
      "            result[i].reserve(group_size[i]);",
      "        }",
      "        for i in 0..size {",
      "            result[root_vec[i]].push(i);",
      "        }",
      "        result",
      "            .into_iter()",
      "            .filter(|x| !x.is_empty())",
      "            .collect::<Vec<Vec<usize>>>()",
      "    }",
      "}"
    ]
  },
  "ext_gcd": {
    "prefix": "ext_gcd",
    "body": [
      "pub fn ext_gcd(a: i64, b: i64) -> (i64, i64, i64) {",
      "    if b == 0 {",
      "        (a, 1, 0)",
      "    } else {",
      "        let (d, q, p) = ext_gcd(b, a % b);",
      "        (d, p, q - a / b * p)",
      "    }",
      "}"
    ]
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "pub fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "lcm": {
    "prefix": "lcm",
    "body": [
      "pub fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "pub fn lcm(a: usize, b: usize) -> usize {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "mod_inv": {
    "prefix": "mod_inv",
    "body": [
      "pub fn ext_gcd(a: i64, b: i64) -> (i64, i64, i64) {",
      "    if b == 0 {",
      "        (a, 1, 0)",
      "    } else {",
      "        let (d, q, p) = ext_gcd(b, a % b);",
      "        (d, p, q - a / b * p)",
      "    }",
      "}",
      "pub fn mod_inv(a: usize, m: i64) -> usize {",
      "    let (_, mut x, _) = ext_gcd(a as i64, m as i64);",
      "    x %= m;",
      "    if x < 0 {",
      "        x += m",
      "    }",
      "    x as usize",
      "}"
    ]
  },
  "mod_pow": {
    "prefix": "mod_pow",
    "body": [
      "pub fn mod_pow(x: usize, mut p: usize, md: usize) -> usize {",
      "    let mut res = 1;",
      "    let mut d = x;",
      "    if p == 0 {",
      "        return 1;",
      "    }",
      "    while p > 0 {",
      "        if p & 1 == 1 {",
      "            res = (res * d) % md;",
      "        }",
      "        d = (d * d) % md;",
      "        p >>= 1;",
      "    }",
      "    res",
      "}"
    ]
  },
  "prime_factorize": {
    "prefix": "prime_factorize",
    "body": [
      "pub fn prime_factorize(mut n: usize) -> Vec<(usize, usize)> {",
      "    let mut res = vec![];",
      "    let mut i = 2;",
      "    while i * i <= n {",
      "        if n % i != 0 {",
      "            i += 1;",
      "            continue;",
      "        }",
      "        let mut ex = 0;",
      "        while n % i == 0 {",
      "            ex += 1;",
      "            n /= i;",
      "        }",
      "        res.push((i, ex));",
      "        i += 1;",
      "    }",
      "    if n != 1 {",
      "        res.push((n, 1));",
      "    }",
      "    res",
      "}"
    ]
  },
  "prime_list": {
    "prefix": "prime_list",
    "body": [
      "pub fn prime_list(n: usize) -> Vec<usize> {",
      "    let mut list = vec![];",
      "    let mut is_prime = vec![true; n + 1];",
      "    for i in 2..n {",
      "        if !is_prime[i] {",
      "            continue;",
      "        }",
      "        list.push(i);",
      "        for j in (i * i..=n).step_by(i) {",
      "            is_prime[j] = false;",
      "        }",
      "    }",
      "    list",
      "}"
    ]
  },
  "shortest_path": {
    "prefix": "shortest_path",
    "body": [
      "type Graph = Vec<Vec<Edge>>;",
      "#[derive(Debug, Copy, Clone)]",
      "pub struct Edge {",
      "    pub to: usize,",
      "    pub cost: usize,",
      "}",
      "impl Edge {",
      "    pub fn new(to: usize, cost: usize) -> Self {",
      "        Self { to, cost }",
      "    }",
      "}",
      "pub fn shortest_path(graph: &Graph, start: usize, goal: usize) -> (usize, Vec<usize>) {",
      "    use std::cmp::Reverse;",
      "    let mut dist = vec![usize::MAX / 2; graph.len()];",
      "    let mut prev = vec![None; graph.len()];",
      "    dist[start] = 0;",
      "    let mut pq = std::collections::BinaryHeap::new();",
      "    pq.push(Reverse((0, start)));",
      "    while let Some(Reverse((cost, pos))) = pq.pop() {",
      "        if dist[pos] < cost {",
      "            continue;",
      "        }",
      "        for edge in &graph[pos] {",
      "            if dist[edge.to] > dist[pos] + edge.cost {",
      "                dist[edge.to] = dist[pos] + edge.cost;",
      "                pq.push(Reverse((dist[edge.to], edge.to)));",
      "                prev[edge.to] = Some(pos);",
      "            }",
      "        }",
      "    }",
      "    let mut id = goal;",
      "    let mut path = vec![goal];",
      "    while let Some(v) = prev[id] {",
      "        path.push(v);",
      "        id = v;",
      "    }",
      "    path.reverse();",
      "    (dist[goal], path)",
      "}"
    ]
  }
}
